<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Codeforces Round 857 (Div. 2) C - E</title>
    <link href="/2023/03/14/cf_1802_C_E/"/>
    <url>/2023/03/14/cf_1802_C_E/</url>
    
    <content type="html"><![CDATA[<p>C (构造) D (贪心、multiset) E (树状数组优化dp)</p><span id="more"></span><h2 id="链接">链接</h2><p><ahref="https://codeforces.com/contest/1802">https://codeforces.com/contest/1802</a></p><h2 id="c-构造">C (构造)</h2><h3 id="题意">题意</h3><p>构造一个 <span class="math inline">\(n \times m\)</span>的矩阵，使得每一个 <span class="math inline">\(2 \times 2\)</span>的子矩阵满足： <span class="math display">\[\begin{matrix} A_{11} \oplus A_{12} \oplus A_{21} \oplusA_{22}=A_{33}\oplus A_{34} \oplus A_{43} \oplus A_{44}\\A_{13} \oplus A_{14} \oplus A_{23} \oplus A_{24}=A_{31}\oplus A_{32}\oplus A_{41} \oplus A_{42}\end{matrix}\]</span></p><h3 id="题解">题解</h3><p>通过观察样例，可以猜想每一个子矩阵的异或和是一个常数。（待证明）<br />因此，我们可以随机化矩阵的第一行和第一列，并设定一个常数 <spanclass="math inline">\(C\)</span>作为每个子矩阵的异或和。对于一个子矩阵，若已知三个数的值 <spanclass="math inline">\(A_{1}, A_{2}, A_{3}\)</span>，则第四个值 <spanclass="math inline">\(A_{4}=C \oplus A_{1} \oplus A_{2} \oplusA_{3}\)</span>。</p><h3 id="python-代码">python 代码</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> randomT = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())mod = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">63</span>) - <span class="hljs-number">1</span>f = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>)]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>):    f[i][<span class="hljs-number">0</span>] = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100000000000000012</span>)    f[<span class="hljs-number">0</span>][i] = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100000000000000012</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>):        f[i][j] = mod ^ f[i - <span class="hljs-number">1</span>][j] ^ f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] ^ f[i][j - <span class="hljs-number">1</span>]<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):    n, m = [<span class="hljs-built_in">int</span>(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]    <span class="hljs-built_in">print</span>(n*m)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%d &#x27;</span> % f[i][j], end=<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-built_in">print</span>()</code></pre></div><h2 id="d-贪心multiset">D (贪心、multiset)</h2><h3 id="题意-1">题意</h3><p>给出两个数组 <span class="math inline">\(a, b\)</span>，操作 <spanclass="math inline">\(n\)</span> 次，对于第 <spanclass="math inline">\(i\)</span> 次，每次只能从 <spanclass="math inline">\(a_{i}、b_{i}\)</span> 中选出一个，记从 <spanclass="math inline">\(a\)</span> 随选出的数列为 <spanclass="math inline">\(a_{choose}\)</span>，从 <spanclass="math inline">\(b\)</span> 中选出的数列为 <spanclass="math inline">\(b_{choose}\)</span>，目标是最小化 $| (a_{choose})- (b_{choose}) | $。</p><h3 id="题解-1">题解</h3><p>将 <span class="math inline">\(a, b\)</span> 一起按照 <spanclass="math inline">\(a\)</span> 从大到小排序，从前往后遍历 <spanclass="math inline">\(a\)</span>，对于 <spanclass="math inline">\(a_{i}\)</span>，将其作为从 <spanclass="math inline">\(a\)</span> 中选出的最大值。<br />由于 <span class="math inline">\(\forall j \in [1,i-1], a_{j} &lt;a_{i}\)</span>，因此，<span class="math inline">\(i\)</span> 前面的<span class="math inline">\(a\)</span> 一定不选，<spanclass="math inline">\(i\)</span> 前面的 <spanclass="math inline">\(b\)</span> 一定要选；<spanclass="math inline">\(i\)</span> 后面的 <spanclass="math inline">\(b\)</span> 可选可不选。<br />记 <span class="math inline">\(mxb = \max(b_{j}, j \in [1,i-1])\)</span>，则只需要在 <span class="math inline">\(i\)</span> 后面的 <spanclass="math inline">\(b\)</span> 中找到和 <spanclass="math inline">\(a_{i}\)</span> 最相近的且 <spanclass="math inline">\(&gt; mxb\)</span> 的数 <spanclass="math inline">\(b_{k}\)</span> 即可用 <spanclass="math inline">\(\left | a_{i} - b_{k} \right |\)</span>更新答案；如果没有找到，则用 <span class="math inline">\(\left | a_{i} -mxb \right |\)</span> 更新答案。<br />可用 <span class="math inline">\(muliset\)</span> 维护，<spanclass="math inline">\(lower_bound\)</span> 用于寻找最相近的数。<br />时间复杂度 <span class="math inline">\(O(nlogn)\)</span></p><h3 id="c-代码">c++ 代码</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> _for( i, L, R ) for ( int i = L; i &lt;= R; ++i )</span>using namespace <span class="hljs-built_in">std</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> &#123;</span>public:<span class="hljs-type">int</span> a, b;<span class="hljs-type">bool</span> operator&lt;( <span class="hljs-type">const</span> Node &amp; o ) <span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span>(a &gt; o.a);&#125;&#125; e[N];<span class="hljs-type">int</span> n;<span class="hljs-type">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span>&#123;<span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;n );<span class="hljs-built_in">multiset</span>&lt;<span class="hljs-type">int</span>&gt; s;_for( i, <span class="hljs-number">1</span>, n ) <span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d%d&quot;</span>, &amp;e[i].a, &amp;e[i].b ), s.insert( e[i].b );sort( e + <span class="hljs-number">1</span>, e + n + <span class="hljs-number">1</span> );<span class="hljs-type">int</span> res = <span class="hljs-number">1e9</span>, mx = <span class="hljs-number">-1e9</span>;_for( i, <span class="hljs-number">1</span>, n )&#123;s.erase( s.find( e[i].b ) );<span class="hljs-keyword">auto</span> it = s.lower_bound( e[i].a );<span class="hljs-keyword">if</span> ( it != s.end() and * it &gt; mx )res = min( res, <span class="hljs-built_in">abs</span>( e[i].a - *it ) );<span class="hljs-keyword">if</span> ( it != s.begin() and * prev( it ) &gt; mx )res = min( res, <span class="hljs-built_in">abs</span>( e[i].a - *prev( it ) ) );res= min( res, <span class="hljs-built_in">abs</span>( e[i].a - mx ) );mx= max( e[i].b, mx );&#125;<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%d\n&quot;</span>, res );&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-type">int</span> T;<span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;T );<span class="hljs-keyword">while</span> ( T-- )solve();<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><h2 id="e-树状数组优化dp">E (树状数组优化dp)</h2><h3 id="题意-2">题意</h3><p>给出 <span class="math inline">\(n\)</span> 个数组，每个数组有 <spanclass="math inline">\(k_{i}\)</span>个数，找到一直数组拼接方式，使得拼接后的数组 <spanclass="math inline">\(b\)</span> 中满足 <spanclass="math inline">\(\forall j \in [1, i-1], b_{i} &gt; b_{j}\)</span>（条件1）的数最多。</p><h3 id="题解-2">题解</h3><p>考虑dp。记 <span class="math display">\[f[i]：前 i 个数组拼接而成的最大答案\]</span></p><ul><li>由于一个数组中可能对答案产生贡献的只有在本数组中满足条件1的数，因此在读入时即可使数组单调递增<br /></li><li>将 <span class="math inline">\(n\)</span>个数组按照最后一个元素从小到大排序，这样在更新 <spanclass="math inline">\(f[i]\)</span>时，前面的状态一定已经被更新完了<br /></li><li>对于 <span class="math inline">\(f[i]\)</span>，其中的某一个数 <spanclass="math inline">\(a_{i, j}\)</span>，贡献来自两部分<ul><li>由于 <span class="math inline">\(\forall p \in [j+1, k_{i}], a_{i,p} &gt; a_{i, j}\)</span>，因此贡献为 <spanclass="math inline">\(k_{i}-j\)</span></li><li>对于最大值小于 <span class="math inline">\(a_{i, j}\)</span> 的数组<span class="math inline">\(a_{s}\)</span>，其贡献为 <spanclass="math inline">\(\max(f[s])\)</span></li></ul></li></ul><p>因此，状态转移方程为<br /><span class="math display">\[f[i] = \max(\max(f[s]) + k_{i} - j), s = \{s| \max(a_{s}) &lt; a_{i,j}\}\]</span> 其中，<span class="math inline">\(\max(f[s])\)</span>可用树状数组维护。<br />时间复杂度 <span class="math inline">\(O(nklogn)\)</span></p><h3 id="c-代码-1">c++ 代码</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optimize(1)</span><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optimize(2)</span><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optimize(3,<span class="hljs-string">&quot;Ofast&quot;</span>,<span class="hljs-string">&quot;inline&quot;</span>)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> _for( i, L, R ) for ( int i = L; i &lt;= R; ++i )</span>using namespace <span class="hljs-built_in">std</span>;<span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">( <span class="hljs-type">int</span> x )</span>&#123;<span class="hljs-keyword">return</span>(x &amp; - x);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span>N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<span class="hljs-type">int</span>n, tr[N], f[N], mxv;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> &#123;</span>public:<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; v;<span class="hljs-type">bool</span> operator&lt;( <span class="hljs-type">const</span> Node &amp; o ) <span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span>(v.back() &lt; o.v.back() );&#125;&#125; a[N];<span class="hljs-type">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">( <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y )</span>&#123;<span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = x; i &lt;= mxv; i += lowbit( i ) )tr[i] = max( tr[i], y );&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">( <span class="hljs-type">int</span> x )</span>&#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = x; i; i -= lowbit( i ) )res = max( res, tr[i] );<span class="hljs-keyword">return</span>(res);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">( <span class="hljs-type">int</span> x )</span>&#123;<span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = x; i &lt;= mxv; i += lowbit( i ) )tr[i] = <span class="hljs-number">0</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span>&#123;<span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;n );mxv = <span class="hljs-number">0</span>;_for( i, <span class="hljs-number">1</span>, n )&#123;<span class="hljs-type">int</span> m;<span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;m );<span class="hljs-keyword">while</span> ( m-- )&#123;<span class="hljs-type">int</span> x;<span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;x );<span class="hljs-keyword">if</span> ( a[i].v.empty() or a[i].v.back() &lt; x )a[i].v.push_back( x ), mxv = max( mxv, x );&#125;&#125;sort( a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n );<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;_for( i, <span class="hljs-number">1</span>, n )&#123;<span class="hljs-type">int</span> k = a[i].v.size(), cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> j = k - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j )&#123;cnt++;f[i] = max( f[i], cnt + query( a[i].v[j] - <span class="hljs-number">1</span> ) );&#125;modify( a[i].v.back(), f[i] );res = max( res, f[i] );&#125;_for( i, <span class="hljs-number">1</span>, n ) clear( a[i].v.back() ), a[i].v.clear(), f[i] = <span class="hljs-number">0</span>;<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%d\n&quot;</span>, res );&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;T );<span class="hljs-keyword">while</span> ( T-- )solve();<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>codeforce, cf, C, D, E, Maximum Subarray, dp, DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 144 (Rated for Div. 2) D. Maximum Subarray (dp)</title>
    <link href="/2023/03/12/cf_1796_D/"/>
    <url>/2023/03/12/cf_1796_D/</url>
    
    <content type="html"><![CDATA[<p>dp <span id="more"></span></p><h1 id="链接">链接</h1><p><ahref="https://codeforces.com/contest/1796/problem/D">https://codeforces.com/contest/1796/problem/D</a></p><h1 id="题意">题意</h1><p>给一个数组 <span class="math inline">\(a\)</span>，要求选出 <spanclass="math inline">\(a\)</span> 的一个长度为 <spanclass="math inline">\(k\)</span> 的子序列 <spanclass="math inline">\(b_{1}, b_{2}, ..., b_{k}\)</span>，让 <spanclass="math inline">\(\forall i \in [1, k], b_{i} += x\)</span>，而让<span class="math inline">\(\forall a_{i} \in a \ and \ a_{i} \notin b,a_{i} -= x\)</span>，使得形成的新数组最大子段和最大。</p><h1 id="题解">题解</h1><p>考虑 DP。<br />设 <span class="math inline">\(f[i][j]\)</span> : 考虑前 <spanclass="math inline">\(i\)</span> 个数，已经选择了 <spanclass="math inline">\(j\)</span> 个数执行 "<spanclass="math inline">\(+x\)</span>" 操作的大子段和。<br />分类讨论：</p><ul><li><span class="math inline">\(a[i]\)</span> 不执行 "<spanclass="math inline">\(+x\)</span>" 操作<ul><li>必须满足 <span class="math inline">\(i &gt; j\)</span>，因为如果<span class="math inline">\(i=j\)</span> 则意味着前 <spanclass="math inline">\(i\)</span> 个数全部执行了 "<spanclass="math inline">\(+x\)</span>" 操作，因此 <spanclass="math inline">\(a[i]\)</span> 必须执行 "<spanclass="math inline">\(+x\)</span>" 操作<br /></li><li><span class="math inline">\(a[i]\)</span> 必须执行 "<spanclass="math inline">\(-x\)</span>" 操作</li><li><span class="math inline">\(a[i]\)</span> 单独作为一个子段和，即<span class="math inline">\(a[i] - x\)</span></li><li><span class="math inline">\(a[i]\)</span> 合并到 <spanclass="math inline">\([1, i-1]\)</span> 的最大子段和中，即 <spanclass="math inline">\(f[i-1, j] + a[i] - x\)</span></li></ul></li><li><span class="math inline">\(a[i]\)</span> 执行 "<spanclass="math inline">\(+x\)</span>" 操作<ul><li><span class="math inline">\(a[i]\)</span> 单独作为一个子段和，即<span class="math inline">\(a[i] + x\)</span></li><li><span class="math inline">\(a[i]\)</span> 合并到 <spanclass="math inline">\([1, i-1]\)</span> 的最大子段和中，即 <spanclass="math inline">\(f[i-1, j-1] + a[i] + x\)</span></li></ul></li></ul><p>因此，状态转移方程为： <span class="math display">\[f[i,j]=\left\{\begin{matrix}max(a[i]-x,f[i-1,j]+a[i]-x)\ \ j&lt;i\\max(a[i]+x, f[i-1, j-1]+a[i]+x)\ \ j &gt; 0\end{matrix}\right.\]</span> 初始条件为：<span class="math inline">\(f[0, 0] =0\)</span></p><h1 id="python-代码">python 代码</h1><div class="code-wrapper"><pre><code class="hljs python">T = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):    n, k, x = [<span class="hljs-built_in">int</span>(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]    a = [<span class="hljs-built_in">int</span>(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]    inf = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)    f = [[-inf <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]    res = <span class="hljs-number">0</span>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):        <span class="hljs-comment"># 当前已经使用的 &quot;+x&quot; 操作 j 最少为 k-(n-i)，即让 i 后面的数全部执行 &quot;+x&quot; 操作</span>        <span class="hljs-comment"># 当前已经使用的 &quot;+x&quot; 操作 j 最多为 i，即让 i 前面的数全部执行 &quot;+x&quot; 操作</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, k-(n-i)), <span class="hljs-built_in">min</span>(i, k)+<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> j &lt; i:                f[i][j] = <span class="hljs-built_in">max</span>(a[i-<span class="hljs-number">1</span>] - x, f[i-<span class="hljs-number">1</span>][j] + a[i-<span class="hljs-number">1</span>] - x)            <span class="hljs-keyword">if</span> j:                <span class="hljs-comment"># 注意此处 f[i][j] 可能已经被更新，因此要带上</span>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], <span class="hljs-built_in">max</span>(a[i-<span class="hljs-number">1</span>] + x, f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + a[i-<span class="hljs-number">1</span>] + x))            <span class="hljs-comment"># 若只考虑当前的最大子段和，其他的 &quot;+x&quot; 操作发生在什么地方对当前结果没有影响</span>            res = <span class="hljs-built_in">max</span>(res, f[i][j])    <span class="hljs-built_in">print</span>(res)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>codeforce, cf, D, Maximum Subarray, dp, DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 856 (Div. 2) A - D</title>
    <link href="/2023/03/11/cf_1794/"/>
    <url>/2023/03/11/cf_1794/</url>
    
    <content type="html"><![CDATA[<p>A (思维) B (思维) C (思维) D (dp)</p><span id="more"></span><h1 id="链接">链接</h1><p>https://codeforces.com/contest/1794</p><h1 id="a">A</h1><h2 id="题意">题意</h2><p>给出一个字符串 <span class="math inline">\(s\)</span> 的所有子串<span class="math inline">\(s_{sub}\)</span> 的随机排列，判断这个字符串<span class="math inline">\(s\)</span> 是否为回文串</p><h2 id="题解">题解</h2><p>找出两个长度最长的子串 <span class="math inline">\(s_{sub,max_{1}}\)</span>、<span class="math inline">\(s_{sub,max_{2}}\)</span>，假设 <span class="math inline">\(s_{sub,max_{1}}\)</span> 是 <span class="math inline">\(s\)</span>的前缀，<span class="math inline">\(s_{sub, max_{2}}\)</span>是 <spanclass="math inline">\(s\)</span> 的后缀，则 <spanclass="math display">\[s = s_{sub, max_{1}}[:] + s_{sub, max_{2}}[-1] \ \ or \  \ s_{sub,max_{1}}[0] + s_{sub, max_{2}}[:]   \]</span> 枚举两者情况即可求得 <spanclass="math inline">\(s\)</span>，最后判断 <spanclass="math inline">\(s\)</span> 是否为回文串即可。</p><h2 id="python-代码">python 代码</h2><div class="code-wrapper"><pre><code class="hljs python">T = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())    s = <span class="hljs-built_in">input</span>().split()    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:        res = s[<span class="hljs-number">0</span>] + s[<span class="hljs-number">1</span>]    <span class="hljs-keyword">else</span>:        mxs = []        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == n-<span class="hljs-number">1</span>:                mxs.append(c)        <span class="hljs-comment"># print(mxs[0][:n-2], mxs[1][1:])</span>        <span class="hljs-keyword">if</span> mxs[<span class="hljs-number">0</span>][:n-<span class="hljs-number">2</span>] == mxs[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>:]:            res = mxs[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + mxs[<span class="hljs-number">0</span>]        <span class="hljs-keyword">else</span>:            res = mxs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + mxs[<span class="hljs-number">1</span>]    <span class="hljs-keyword">if</span> res == res[::-<span class="hljs-number">1</span>]:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;YES&#x27;</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;NO&#x27;</span>)</code></pre></div><h1 id="b">B</h1><h2 id="题意-1">题意</h2><p>给一个数组 <span class="math inline">\(a\)</span>，每一次操作可以让<span class="math inline">\(a_{i}=a_{i}+1\)</span>，最多操作 <spanclass="math inline">\(n\)</span> 次，要求最后使得 <spanclass="math inline">\(a\)</span> 满足 <span class="math display">\[\forall i \in [1, n-1], a_{i} \ not\  \mid a_{i+1}\]</span></p><h2 id="题解-1">题解</h2><p>贪心即可。 从前往后遍历，只要 <span class="math inline">\(a_{i-1}\mid a_{i}\)</span>，因为 <span class="math inline">\(a_{i-1}+1\)</span>可能是 <span class="math inline">\(a_{i}\)</span> 的因子，而 <spanclass="math inline">\(a_{i-1}\)</span> 不可能是 <spanclass="math inline">\(a_{i}+1\)</span> 的因子，因此就让 <spanclass="math inline">\(a_{i} += 1\)</span>。 注意，当 <spanclass="math inline">\(a_{i-1}=1\)</span> 时，恒有 <spanclass="math inline">\(a_{i-1} | (a_{i}+1)\)</span>，因此如果 <spanclass="math inline">\(\exists k \in [1, n], a_{k}=1\)</span>，则使 <spanclass="math inline">\(a_{k} += 1\)</span>。</p><h2 id="python-代码-1">python 代码</h2><div class="code-wrapper"><pre><code class="hljs python">T = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())    a = [<span class="hljs-built_in">int</span>(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> a:        a = [_ + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> a]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):        <span class="hljs-keyword">if</span> a[i] % a[i-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:            a[i] += <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%d &#x27;</span> % x, end=<span class="hljs-string">&#x27;&#x27;</span>)    <span class="hljs-built_in">print</span>()</code></pre></div><h1 id="c">C</h1><h2 id="题意-2">题意</h2><p>给一个单调非减数组 <span class="math inline">\(a\)</span>，<spanclass="math inline">\(\forall i \in [1, n]\)</span>，在 <spanclass="math inline">\(a_{j}, j \in [1, i]\)</span> 中选出一个子序列<span class="math inline">\(s_{1}, s_{2}, ..., s_{d}\)</span>，要使$maxsocre_{i} = $，输出 <spanclass="math inline">\(score_{i}\)</span>。</p><h2 id="题解-2">题解</h2><p>注意到，<span class="math inline">\(a\)</span>是一个单调非减的序列，且对于 <span class="math inline">\(score =\frac{s_{1}*s_{2}*...*s_{d}}{d!}\)</span>，如果想要加入一个数 <spanclass="math inline">\(s_{d+1}\)</span>，则 <spanclass="math inline">\(socre *= \frac{s_{d+1}}{d+1}\)</span>。因此对于某一个前缀 <span class="math inline">\(a_{j}, j \in [1,i]\)</span>，我们可以这样让 <span class="math inline">\(score\)</span>最大化： - <span class="math inline">\(score = a_{j}\)</span> - <spanclass="math inline">\(if a_{j-1}/2 &gt; 1，则score = \frac{a_{j} *a_{j-1}}{2}\)</span> - 依次类推<br />因此，我们可以从前往后扫，用一个队列来维护 <spanclass="math inline">\(score\)</span>的最大值，每次只需要判断队列前面的是否需要删除即可。</p><h2 id="python-代码-2">python 代码</h2><div class="code-wrapper"><pre><code class="hljs python">T = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())    a = [<span class="hljs-built_in">int</span>(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]    res, l, r = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>    que = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a:        r += <span class="hljs-number">1</span>        que[r] = x        res += <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> que[l] &lt; res <span class="hljs-keyword">and</span> l &lt; r:            l += <span class="hljs-number">1</span>            res -= <span class="hljs-number">1</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%d &#x27;</span> % res, end=<span class="hljs-string">&#x27;&#x27;</span>)    <span class="hljs-built_in">print</span>()</code></pre></div><h1 id="d">D</h1><h2 id="题意-3">题意</h2><p>给出一个长度为 <span class="math inline">\(2n\)</span> 的数组 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(a\)</span>的某一个排列是某一个数的质因数分解，即 <span class="math display">\[f(m) = \{p_{1}, e_{1}, p_{2}, e_{2}, ..., p_{k}, e_{k}\}\]</span> 求有多少个这样的数，模 <spanclass="math inline">\(998244353\)</span>。</p><h2 id="题解-3">题解</h2><p>首先考虑特殊情况，当 <span class="math inline">\(a\)</span>中的素数数量 <span class="math inline">\(&lt;n\)</span> 时，答案显然为<span class="math inline">\(0\)</span>。 注意到，当选定 <spanclass="math inline">\(n\)</span> 个数为底数时，剩下的 <spanclass="math inline">\(n\)</span> 个数做全排列。设 <spanclass="math inline">\(a\)</span> 去重后为 <spanclass="math inline">\(b\)</span>，由多重集全排列理论可知，全排列数为<span class="math display">\[\frac{n!}{cnt_{b_{1}}! * cnt_{b_{2}}! * .. cnt_{b_{m}}!}  \]</span> 其中 <span class="math inline">\(cnt_{b_{k}}\)</span> 是 <spanclass="math inline">\(b_{k}\)</span> 的数量。<br />当 <span class="math inline">\(b_{k}\)</span>为非素数时，贡献是固定的，因为它们都不能作为底数。而当 <spanclass="math inline">\(b_{k}\)</span>为素数时，贡献是不固定的，因为当它们作为底数时，贡献为 <spanclass="math inline">\(\frac{1}{(cnt_{b_{k}}-1)!}\)</span>，而这个部分可以用<span class="math inline">\(dp\)</span> 来求。<br />设 <span class="math inline">\(f_{i, j}\)</span> 为处理到第 <spanclass="math inline">\(i\)</span> 种数，以 <spanclass="math inline">\(j\)</span> 个数作为底数时的贡献。考虑如何从 <spanclass="math inline">\(f_{i-1}\)</span> 转移：<br />- 当第 <span class="math inline">\(i\)</span> 种数不作为底数时，则$f_{i,j} = $，因为前后的底数数量 <span class="math inline">\(j\)</span>是一样的 - 当第 <span class="math inline">\(i\)</span>种数作为底数时，则 <span class="math inline">\(f_{i,j} =\frac{f_{i-1,j-1}}{(cnt_{b_{i}}-1)!}\)</span>，因为当前比上一次多一个底数<br /><span class="math inline">\(f_{m, n}\)</span> 即为素数的贡献，其中 <spanclass="math inline">\(m\)</span> 是数的种类。<br />最后，设 <span class="math inline">\(b\)</span> 中的非素数部分为 <spanclass="math inline">\(c\)</span>，则 <span class="math display">\[res =\frac{n}{cnt_{c_{1}}! * cnt_{c_{2}}! *...} * f_{m, n}\]</span></p><h2 id="c-代码">c++ 代码</h2><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(b) &#123;        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) res = res * a % mod;        a = a * a % mod;        b &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span> * n)</span></span>;    <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);        mx = <span class="hljs-built_in">max</span>(mx, a[i]);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">primes</span><span class="hljs-params">(mx + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">not_prime</span><span class="hljs-params">(mx + <span class="hljs-number">1</span>)</span></span>;    not_prime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> cnt_primes = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= mx; i++) &#123;        <span class="hljs-keyword">if</span>(!not_prime[i]) primes[++cnt_primes] = i;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt_primes <span class="hljs-keyword">and</span> i * primes[j] &lt;= mx; j++) &#123;            not_prime[i * primes[j]] = <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fac</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">inv</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * i % mod;    inv[<span class="hljs-number">0</span>] = inv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) inv[i] = <span class="hljs-built_in">qmi</span>(fac[i], mod - <span class="hljs-number">2</span>);    vector&lt;<span class="hljs-type">int</span>&gt; p, np;    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++) &#123;        cnt[a[i]]++;        <span class="hljs-keyword">if</span>(cnt[a[i]] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span>(not_prime[a[i]]) np.<span class="hljs-built_in">push_back</span>(a[i]);            <span class="hljs-keyword">else</span> p.<span class="hljs-built_in">push_back</span>(a[i]);        &#125;    &#125;    <span class="hljs-keyword">if</span>(p.<span class="hljs-built_in">size</span>() &lt; n) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-type">int</span> res = fac[n];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; np.<span class="hljs-built_in">size</span>(); i++) &#123;        res = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res * inv[cnt[np[i]]] % mod;    &#125;    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(p.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= p.<span class="hljs-built_in">size</span>(); i++) &#123;        f[i][<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] * inv[cnt[p[i - <span class="hljs-number">1</span>]]] % mod;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n &amp;&amp; j &lt;= i; j++) &#123;            f[i][j] = ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)f[i - <span class="hljs-number">1</span>][j] * inv[cnt[p[i - <span class="hljs-number">1</span>]]] % mod + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] * inv[cnt[p[i - <span class="hljs-number">1</span>]] - <span class="hljs-number">1</span>] % mod) % mod;        &#125;    &#125;    res = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res * f[p.<span class="hljs-built_in">size</span>()][n] % mod; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>codeforce, Codeforces Round 856 (Div. 2) A - D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo配置博客</title>
    <link href="/2023/03/09/%E4%BD%BF%E7%94%A8hexo%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/03/09/%E4%BD%BF%E7%94%A8hexo%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="生成">生成</h1><p><code>hexo g</code></p><h1 id="预览">预览</h1><p><code>hexo s</code></p><h1 id="部署">部署</h1><p><code>hexo d</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo, blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yolov5配置</title>
    <link href="/2023/02/09/yolov5%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/02/09/yolov5%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="项目配置教程">项目配置教程</h1><h2 id="安装与环境配置">1. 安装与环境配置</h2><ul><li><p>安装 Pycharm<br />下载地址https://www.jetbrains.com/zh-cn/pycharm/download/#section=windows(下载最新版即可)</p></li><li><p>安装 Anaconda<br />下载地址https://www.anaconda.com/products/distribution/start-coding-immediately(下载最新版即可)<br />此后所有命令都在 Anaconda Prompt (Anaconda3) 中运行</p></li><li><p>创建虚拟环境<br />打开 Anaconda Prompt (Anaconda3)<br />创建虚拟环境： <div class="code-wrapper"><pre><code class="hljs c">conda create -n 自定义的名称(例如 vexento) python==<span class="hljs-number">3.7</span><span class="hljs-number">.2</span></code></pre></div> 检查当前的虚拟环境： <div class="code-wrapper"><pre><code class="hljs c">conda env <span class="hljs-built_in">list</span></code></pre></div> 如果python 版本安装错误，则在 base 环境中输入 <div class="code-wrapper"><pre><code class="hljs c">conda install python==<span class="hljs-number">3.7</span><span class="hljs-number">.2</span> -n 要修改的环境名(例如 vexento)</code></pre></div></p></li><li><p>更改 pycharm 的解释器<br /><div class="code-wrapper"><pre><code class="hljs c">--&gt; File --&gt; Settings --&gt; Project --&gt; Python Interprerter--&gt; Add Interpreter --&gt; Add Local Interpreter --&gt; Virtualenv Enviroment 中的 Existing --&gt; ... --&gt; 找到上一步虚拟环境地址中的 python.exe --&gt; OK</code></pre></div></p></li><li><p>安装 cuda 11.7<br />下载地址：https://developer.nvidia.com/cuda-11-7-1-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local</p></li></ul><p>默认安装即可</p><ul><li><p>安装 cudNN<br />下载地址：https://developer.nvidia.com/rdp/cudnn-archive (选择对应版本for CUDA 11.x)<br />解压，将解压后的所有文件复制到 cuda 11.7 安装文件夹<div class="code-wrapper"><pre><code class="hljs c">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11<span class="hljs-number">.7</span></code></pre></div></p></li><li><p>安装 Pytorch<br />打开 Anaconda Prompt (Anaconda3)<br />激活虚拟环境： <div class="code-wrapper"><pre><code class="hljs c">activate 虚拟环境的名称(例如 vexento)</code></pre></div> 下载 Pytorch： <div class="code-wrapper"><pre><code class="hljs 想·">  pip3 install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu117  --default-timeout=10000  ```  下载 torchvision：</code></pre></div> python -m pipinstall -i http://pypi.tuna.tsinghua.edu.cn/simple --trusted-hostpypi.tuna.tsinghua.edu.cn torchvision <div class="code-wrapper"><pre><code class="hljs awk">  打开 Pycharm, 等待 Pycharm 更新解释器      - 下载 yolov5    下载地址：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ultralytics/y</span>olov5    解压缩  - 安装需要的包  - 进入 yolov5-master 文件夹：    ```c    cd yolov5-master的路径</code></pre></div> 下载 yolov5所需要的包： <div class="code-wrapper"><pre><code class="hljs c">pip install -r requirements.txt -i https:<span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple  --default-timeout=10000 </span></code></pre></div></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>yolov5</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
